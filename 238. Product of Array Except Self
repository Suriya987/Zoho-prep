Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].

The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.

You must write an algorithm that runs in O(n) time and without using the division operation.

 

Example 1:

Input: nums = [1,2,3,4]
Output: [24,12,8,6]
Example 2:

Input: nums = [-1,1,0,-3,3]
Output: [0,0,9,0,0]
 

Constraints:

2 <= nums.length <= 105
-30 <= nums[i] <= 30
The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.
 

Follow up: Can you solve the problem in O(1) extra space complexity? (The output array does not count as extra space for space complexity analysis.)


Time complexity : O(N)
Space complexity : O(1)

class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
          
             
              int len=nums.size();
               vector<int> res(len,0);
              //prefix
              int pref=1;
              for(int i=0;i<len;i++)
              {
                  res[i]=pref;
                  pref=pref*nums[i];   // 1 1 2 6 
              }

              //postfix
              int post=1;
              for(int i=len-1;i>=0;i--)
              {
                  res[i]=post*res[i];
                  post=post*nums[i];
              }
              return res;

    }
};

Time complexity : O(N)
space complexity : O(2N)

   /*       vector<int>prefix;
          vector<int>postfix(nums.size(),0);
          vector<int> res;
          int len=nums.size();
           int prefProd=nums[0];
          //prefix
          for(int i=0;i<len-1;i++)
          {
             prefix.push_back(prefProd);
             prefProd=prefProd*nums[i+1];
          }
          prefix.push_back(prefProd);
          
           //post fix
           int postProd=nums[len-1];
           int k=len-1;
           for(int i=len-1;i>0;i--)
           {
            postfix[k--]=postProd;
             // postfix.push_back(postProd);       24 24 12 4     4 12 24 24 
                 postProd=postProd*nums[i-1];
           }
           postfix[k--]=postProd;
          // postfix.push_back(postProd);

         // return postfix;
           
          
          //computing
            for(int i=0;i<len;i++)
            {
                if(i==0) //there are no prefix
                {
                     res.push_back(postfix[i+1]);
                }
                else if(i==len-1)
                {
                    res.push_back(prefix[i-1]);
                }
                else
                {
                    int val=prefix[i-1]*postfix[i+1];
                    res.push_back(val);
                }
            }
            return res;

    }
};
*/
